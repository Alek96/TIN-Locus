Added threads_layer::BlockingMessageQueue::release_access_mutex_on_thread_cancel_cleanup
	for releasing Monitor's access_mutex when the sender_thread is cancelled by the receiver_thread
	sender_thread can be (and in most cases will be) cancelled while blocked on condition variable empty_cond
		thus re-acquiring the access_mutex and not releasing it before exiting
	(mutex must be released (unlocked) before destroying it)
	
	YET TODO: check if mutex is locked before attempting to release it!
	YET TODO: check other possible cancellation points of the sender_thread (pthread_cond_wait, send, ..other?..)
	
	This method is called by clients::internals::sender_thread_cleanup_handler
		which is registered as sender_thread's clean-up handler
		
Added clients::internals::sender_thread_cleanup_handler
	as a friend of the threads_layer::BlockingMessageQueue
	

Modified sender_thread as a joinable thread instead of detached one as it were before
	receiver_thread now joins with (waits for termination of) the sender_thread
		this is a synchronization point between this two threads
			after termination of the sender_thread, receiver_thread closes underlying comm_endpoint,
			remove client (ClientManager) from the SessionManager and terminates its execution
				in this way connection between the server and this client has been closed
				
Added clients::ClientManager::sendToPeersInSession
	uses clients::SessionManager::sendToAllClientsOtherThan

Added clients::ClientManager::sendToAllInSession
	uses clients::SessionManager::sendToAllClients
	
Added class clients::SessionManager
	as a container of all clients (ClientManager-s) connected to the server
	enables sending messages to all connected clients and to all connected peers (all clients excluding the given one (as intended: the sender))